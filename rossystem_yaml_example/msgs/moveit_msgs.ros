moveit_msgs:
  specs:
     msg: CostSource
       message:
         # The density of the cost source float64 cost_density # The volume of the cost source is represented as an # axis-aligned bounding box (AABB) # The AABB is specified by two of its opposite corners "geometry_msgs.Vector3" aabb_min "geometry_msgs.Vector3" aabb_max
     msg: MotionPlanDetailedResponse
       message:
         # The representation of a solution to a planning problem, including intermediate data # The starting state considered for the robot solution path RobotState trajectory_start # The group used for planning (usually the same as in the request) string group_name # Multiple solution paths are reported, each reflecting intermediate steps in the trajectory processing # The list of reported trajectories RobotTrajectory[] trajectory # Description of the reported trajectories (name of processing step) string[] description # The amount of time spent computing a particular step in motion plan computation float64[] processing_time # Status at the end of this plan MoveItErrorCodes error_code
     msg: OrientedBoundingBox
       message:
         # the pose of the box "geometry_msgs.Pose" pose # the extents of the box, assuming the center is at the origin "geometry_msgs.Point32" extents
     msg: PlanningScene
       message:
         # name of planning scene string name # full robot state RobotState robot_state # The name of the robot model this scene is for string robot_model_name #additional frames for duplicating tf (with respect to the planning frame) "geometry_msgs.TransformStamped"[] fixed_frame_transforms #full allowed collision matrix AllowedCollisionMatrix allowed_collision_matrix # all link paddings LinkPadding[] link_padding # all link scales LinkScale[] link_scale # Attached objects, collision objects, even the octomap or collision map can have # colors associated to them. This array specifies them. ObjectColor[] object_colors # the collision map PlanningSceneWorld world # Flag indicating whether this scene is to be interpreted as a diff with respect to some other scene bool is_diff
     msg: LinkPadding
       message:
         #name for the link string link_name # padding to apply to the link float64 padding
     srv: GetPositionIK
       request:
         # A service call to carry out an inverse kinematics computation # The inverse kinematics request PositionIKRequest ik_request

       response:
         # The returned solution # (in the same order as the list of joints specified in the IKRequest message) RobotState solution MoveItErrorCodes error_code
     msg: CartesianTrajectoryPoint
       message:
         # The definition of a cartesian point in a trajectory. Defines the cartesian state of the point and it's time, # following the pattern of the JointTrajectory message CartesianPoint point "builtin_interfaces.Duration" time_from_start
     msg: OrientationConstraint
       message:
         # This message contains the definition of an orientation constraint. "std_msgs.Header" header # The desired orientation of the robot link specified as a quaternion "geometry_msgs.Quaternion" orientation # The robot link this constraint refers to string link_name # Tolerance on the three vector components of the orientation error (optional) # This is a "+.-" tolerance i.e. (+ x_axis_tol, - x_axis_tol) float64 absolute_x_axis_tolerance float64 absolute_y_axis_tolerance float64 absolute_z_axis_tolerance # Defines how the orientation error is calculated # The error is compared to the tolerance defined above uint8 parameterization # The different options for the orientation error parameterization # - Intrinsic xyz Euler angles (default value) uint8 XYZ_EULER_ANGLES=0 # - A rotation vector. This is similar to the angle-axis representation, # but the magnitude of the vector represents the rotation angle. uint8 ROTATION_VECTOR=1 # A weighting factor for this constraint (denotes relative importance to other constraints. Closer to zero means less important) float64 weight
     msg: VisibilityConstraint
       message:
         # The constraint is useful to maintain visibility to a disc (the target) in a particular frame. # This disc forms the base of a visibiliy cone whose tip is at the origin of the sensor. # Maintaining visibility is done by ensuring the robot does not obstruct the visibility cone. # Note: # This constraint does NOT enforce minimum or maximum distances between the sensor # and the target, nor does it enforce the target to be in the field of view of # the sensor. A PositionConstraint can (and probably should) be used for such purposes. # The radius of the disc that should be maintained visible float64 target_radius # The pose of the disc; as the robot moves, the pose of the disc may change as well # This can be in the frame of a particular robot link, for example "geometry_msgs.PoseStamped" target_pose # From the sensor origin towards the target, the disc forms a visibility cone # This cone is approximated using many sides. For example, when using 4 sides, # that in fact makes the visibility region be a pyramid. # This value should always be 3 or more. int32 cone_sides # The pose in which visibility is to be maintained. # The frame id should represent the robot link to which the sensor is attached. # It is assumed the sensor can look directly at the target, in any direction. # This assumption is usually not true, but additional PositionConstraints # can resolve this issue. "geometry_msgs.PoseStamped" sensor_pose # Even though the disc is maintained visible, the visibility cone can be very small # because of the orientation of the disc with respect to the sensor. It is possible # for example to view the disk almost from a side, in which case the visibility cone # can end up having close to 0 volume. The view angle is defined to be the angle between # the normal to the visibility disc and the direction vector from the sensor origin. # The value below represents the minimum desired view angle. For a perfect view, # this value will be 0 (the two vectors are exact opposites). For a completely obstructed view # this value will be "Pi.2" (the vectors are perpendicular). This value defined below # is the maximum view angle to be maintained. This should be a value in the open interval # (0, "Pi.2)." If 0 is set, the view angle is NOT enforced. float64 max_view_angle # This angle is used similarly to max_view_angle but limits the maximum angle # between the sensor origin direction vector and the axis that connects the # sensor origin to the target frame origin. The value is again in the range (0, "Pi.2)" # and is NOT enforced if set to 0. float64 max_range_angle # The axis that is assumed to indicate the direction of view for the sensor # X=2, Y=1, Z=0 uint8 SENSOR_Z=0 uint8 SENSOR_Y=1 uint8 SENSOR_X=2 uint8 sensor_view_direction # A weighting factor for this constraint (denotes relative importance to other constraints. Closer to zero means less important) float64 weight
     msg: AllowedCollisionMatrix
       message:
         # The list of entry names in the matrix string[] entry_names # The individual entries in the allowed collision matrix # square, symmetric, with same order as entry_names AllowedCollisionEntry[] entry_values # In addition to the collision matrix itself, we also have # the default entry value for each entry name. # If the allowed collision flag is queried for a pair of names (n1, n2) # that is not found in the collision matrix itself, the value of # the collision flag is considered to be that of the entry (n1 or n2) # specified in the list below. If both n1 and n2 are found in the list # of defaults, the result is computed with an AND operation string[] default_entry_names bool[] default_entry_values
     srv: ExecuteKnownTrajectory
       request:
         # This service is deprecated and will go away at some point. For new development use the ExecuteTrajectory action. # Effective since: Indigo 0.7.4, Jade and Kinetic 0.8.3 # The trajectory to execute RobotTrajectory trajectory # Set this to true if the service should block until the execution is complete bool wait_for_execution

       response:
         # Error code - encodes the overall reason for failure MoveItErrorCodes error_code
     msg: BoundingVolume
       message:
         # Define a volume in 3D # A set of solid geometric primitives that make up the volume to define (as a union) "shape_msgs.SolidPrimitive"[] primitives # The poses at which the primitives are located "geometry_msgs.Pose"[] primitive_poses # In addition to primitives, meshes can be specified to add to the bounding volume (again, as union) "shape_msgs.Mesh"[] meshes # The poses at which the meshes are located "geometry_msgs.Pose"[] mesh_poses
     srv: GetRobotStateFromWarehouse
       request:
         string name string robot

       response:
         "moveit_msgs.RobotState" state
     msg: GripperTranslation
       message:
         # defines a translation for the gripper, used in pickup or place tasks # for example for lifting an object off a table or approaching the table for placing # the direction of the translation "geometry_msgs.Vector3Stamped" direction # the desired translation distance float32 desired_distance # the min distance that must be considered feasible before the # grasp is even attempted float32 min_distance
     srv: GraspPlanning
       request:
         # Requests that grasp planning be performed for the target object # returns a list of candidate grasps to be tested and executed # the planning group used string group_name # the object to be grasped CollisionObject target # the names of the relevant support surfaces (e.g. tables) in the collision map # can be left empty if no names are available string[] support_surfaces # an optional list of grasps to be evaluated by the planner Grasp[] candidate_grasps # an optional list of obstacles that we have semantic information about # and that can be moved in the course of grasping CollisionObject[] movable_obstacles

       response:
         # the list of planned grasps Grasp[] grasps # whether an error occurred MoveItErrorCodes error_code
     srv: GetPlannerParams
       request:
         # Name of the planning pipeline, uses default if empty string pipeline_id # Name of planning config string planner_config # Optional name of planning group (return global defaults if empty) string group

       response:
         # parameters as key-value pairs PlannerParams params
     srv: LoadMap
       request:
         string filename

       response:
         bool success
     msg: PlanningOptions
       message:
         # The diff to consider for the planning scene (optional) PlanningScene planning_scene_diff # If this flag is set to true, the action # returns an executable plan in the response but does not attempt execution bool plan_only # If this flag is set to true, the action of planning & # executing is allowed to look around (move sensors) if # it seems that not enough information is available about # the environment bool look_around # If this value is positive, the action of planning & executing # is allowed to look around for a maximum number of attempts; # If the value is left as 0, the default value is used, as set # with dynamic_reconfigure int32 look_around_attempts # If set and if look_around is true, this value is used as # the maximum cost allowed for a path to be considered executable. # If the cost of a path is higher than this value, more sensing or # a new plan needed. If left as 0.0 but look_around is true, then # the default value set via dynamic_reconfigure is used float64 max_safe_execution_cost # If the plan becomes invalidated during execution, it is possible to have # that plan recomputed and execution restarted. This flag enables this # functionality bool replan # The maximum number of replanning attempts int32 replan_attempts # The amount of time to wait in between replanning attempts (in seconds) float64 replan_delay
     srv: SaveMap
       request:
         string filename

       response:
         bool success
     msg: AllowedCollisionEntry
       message:
         # whether or not collision checking is enabled bool[] enabled
     srv: QueryPlannerInterfaces
       request:

       response:
         # The planning instances that could be used in the benchmark PlannerInterfaceDescription[] planner_interfaces
     msg: AttachedCollisionObject
       message:
         # The CollisionObject will be attached with a fixed joint to this link string link_name #This contains the actual shapes and poses for the CollisionObject #to be attached to the link #If action is remove and no object.id is set, all objects #attached to the link indicated by link_name will be removed CollisionObject object # The set of links that the attached objects are allowed to touch # by default - the link_name is already considered by default string[] touch_links # If certain links were placed in a particular posture for this object to remain attached # (e.g., an end effector closing around an object), the posture necessary for releasing # the object is stored here "trajectory_msgs.JointTrajectory" detach_posture # The weight of the attached object, if known float64 weight
     srv: UpdatePointcloudOctomap
       request:
         "sensor_msgs.PointCloud2" cloud

       response:
         bool success
     msg: PlanningSceneWorld
       message:
         # collision objects CollisionObject[] collision_objects # The octomap that represents additional collision data "octomap_msgs.OctomapWithPose" octomap
     msg: RobotState
       message:
         # This message contains information about the robot state, i.e. the positions of its joints and links "sensor_msgs.JointState" joint_state # Joints that may have multiple DOF are specified here "sensor_msgs.MultiDOFJointState" multi_dof_joint_state # Attached collision objects (attached to some link on the robot) AttachedCollisionObject[] attached_collision_objects # Flag indicating whether this scene is to be interpreted as a diff with respect to some other scene # This is mostly important for handling the attached bodies (whether or not to clear the attached bodies # of a moveit::core::RobotState before updating it with this message) bool is_diff
     msg: PlanningSceneComponents
       message:
         # This message defines the components that make up the PlanningScene message. # The values can be used as a bitfield to specify which parts of the PlanningScene message # are of interest # Scene name, model name, model root uint32 SCENE_SETTINGS=1 # Joint values of the robot state uint32 ROBOT_STATE=2 # Attached objects (including geometry) for the robot state uint32 ROBOT_STATE_ATTACHED_OBJECTS=4 # The names of the world objects uint32 WORLD_OBJECT_NAMES=8 # The geometry of the world objects uint32 WORLD_OBJECT_GEOMETRY=16 # The maintained octomap uint32 OCTOMAP=32 # The maintained list of transforms uint32 TRANSFORMS=64 # The allowed collision matrix uint32 ALLOWED_COLLISION_MATRIX=128 # The default link padding and link scaling uint32 LINK_PADDING_AND_SCALING=256 # The stored object colors uint32 OBJECT_COLORS=512 # Bitfield combining options indicated above uint32 components
     msg: MotionPlanRequest
       message:
         # This service contains the definition for a request to the motion # planner and the output it provides # Parameters for the workspace that the planner should work inside WorkspaceParameters workspace_parameters # Starting state updates. If certain joints should be considered # at positions other than the current ones, these positions should # be set here RobotState start_state # The possible goal states for the model to plan for. Each element of # the array defines a goal region. The goal is achieved # if the constraints for a particular region are satisfied Constraints[] goal_constraints # No state at any point along the path in the produced motion plan will violate these constraints (this applies to all points, not just waypoints) Constraints path_constraints # The constraints the resulting trajectory must satisfy TrajectoryConstraints trajectory_constraints # A set of trajectories that may be used as reference or initial trajectories for (typically optimization-based) planners # These trajectories do not override start_state or goal_constraints GenericTrajectory[] reference_trajectories # The name of the planning pipeline to use. If no name is specified, # the configured planning pipeline will be used string pipeline_id # The name of the planning algorithm to use. If no name is specified, # the default planner of the planning pipeline will be used string planner_id # The name of the group of joints on which this planner is operating string group_name # The number of times this plan is to be computed. Shortest solution # will be reported. int32 num_planning_attempts # The maximum amount of time the motion planner is allowed to plan for (in seconds) float64 allowed_planning_time # Scaling factors for optionally reducing the maximum joint velocities and # accelerations. Allowed values are in (0,1]. The maximum joint velocity and # acceleration specified in the robot model are multiplied by thier respective # factors. If either are outside their valid ranges (importantly, this # includes being set to 0.0), the factor is set to the default value of 1.0 # internally (i.e., maximum joint velocity or maximum joint acceleration). float64 max_velocity_scaling_factor float64 max_acceleration_scaling_factor # Maximum cartesian speed for the given end effector. # If max_cartesian_speed <= 0 the trajectory is not modified. # These fields require the following planning request adapter: "default_planner_request_adapters.SetMaxCartesianEndEffectorSpeed" string cartesian_speed_end_effector_link float64 max_cartesian_speed # "m.s"
     msg: MotionPlanResponse
       message:
         # The representation of a solution to a planning problem # The corresponding robot state RobotState trajectory_start # The group used for planning (usually the same as in the request) string group_name # A solution trajectory, if found RobotTrajectory trajectory # Planning time (seconds) float64 planning_time # Error code - encodes the overall reason for failure MoveItErrorCodes error_code
     msg: LinkScale
       message:
         #name for the link string link_name # scaling to apply to the link float64 scale
     msg: CollisionObject
       message:
         # a header, used for interpreting the poses "std_msgs.Header" header # DISCLAIMER: This field is not in use yet and all other poses # are still interpreted in the header frame. # "https:..github.com.ros-planning.moveit.pull.2037" # implements the actual logic for this field. # --- # The object's pose relative to the header frame. # The shapes and subframe poses are defined relative to this pose. "geometry_msgs.Pose" pose # The id of the object (name used in MoveIt) string id # The object type in a database of known objects "object_recognition_msgs.ObjectType" type # The collision geometries associated with the object. # Their poses are with respect to the object's pose # Solid geometric primitives "shape_msgs.SolidPrimitive"[] primitives "geometry_msgs.Pose"[] primitive_poses # Meshes "shape_msgs.Mesh"[] meshes "geometry_msgs.Pose"[] mesh_poses # Bounding planes (equation is specified, but the plane can be oriented using an additional pose) "shape_msgs.Plane"[] planes "geometry_msgs.Pose"[] plane_poses # Named subframes on the object. Use these to define points of interest on the object that you want # to plan with (e.g. "tip", "spout", "handle"). The id of the object will be prepended to the subframe. # If an object with the id "screwdriver" and a subframe "tip" is in the scene, you can use the frame # ""screwdriver.tip"" for planning. # The length of the subframe_names and subframe_poses has to be identical. string[] subframe_names "geometry_msgs.Pose"[] subframe_poses # Adds the object to the planning scene. If the object previously existed, it is replaced. byte ADD=0 # Removes the object from the environment entirely (everything that matches the specified id) byte REMOVE=1 # Append to an object that already exists in the planning scene. If the object does not exist, it is added. byte APPEND=2 # If an object already exists in the scene, new poses can be sent (the geometry arrays must be left empty) # if solely moving the object is desired byte MOVE=3 # Operation to be performed byte operation
     msg: Grasp
       message:
         # This message contains a description of a grasp that would be used # with a particular end-effector to grasp an object, including how to # approach it, grip it, etc. This message does not contain any # information about a "grasp point" (a position ON the object). # Whatever generates this message should have already combined # information about grasp points with information about the geometry # of the end-effector to compute the grasp_pose in this message. # A name for this grasp string id # The internal posture of the hand for the pre-grasp # only positions are used "trajectory_msgs.JointTrajectory" pre_grasp_posture # The internal posture of the hand for the grasp # positions and efforts are used "trajectory_msgs.JointTrajectory" grasp_posture # The position of the end-effector for the grasp. This is the pose of # the "parent_link" of the end-effector, not actually the pose of any # link *in* the end-effector. Typically this would be the pose of the # most distal wrist link before the hand (end-effector) links began. "geometry_msgs.PoseStamped" grasp_pose # The estimated probability of success for this grasp, or some other # measure of how "good" it is. float64 grasp_quality # The approach direction to take before picking an object GripperTranslation pre_grasp_approach # The retreat direction to take after a grasp has been completed (object is attached) GripperTranslation post_grasp_retreat # The retreat motion to perform when releasing the object; this information # is not necessary for the grasp itself, but when releasing the object, # the information will be necessary. The grasp used to perform a pickup # is returned as part of the result, so this information is available for # later use. GripperTranslation post_place_retreat # the maximum contact force to use while grasping (<=0 to disable) float32 max_contact_force # an optional list of obstacles that we have semantic information about # and that can be "touched.pushed.moved" in the course of grasping string[] allowed_touch_objects
     srv: SetPlannerParams
       request:
         # Name of the planning pipeline, uses default if empty string pipeline_id # Name of planning config string planner_config # Optional name of planning group (set global defaults if empty) string group # parameters as key-value pairs PlannerParams params # replace params or augment existing ones? bool replace

       response:
     msg: MotionSequenceResponse
       message:
         # An error code reflecting what went wrong MoveItErrorCodes error_code # The full starting state of the robot at the start of the sequence RobotState sequence_start # The trajectories that the planner produced for execution RobotTrajectory[] planned_trajectories # The amount of time it took to complete the motion plan float64 planning_time
     msg: ObjectColor
       message:
         # The object id for which we specify color string id # The value of the color "std_msgs.ColorRGBA" color
     msg: JointLimits
       message:
         # This message contains information about limits of a particular joint (or control dimension) string joint_name # true if the joint has position limits bool has_position_limits # min and max position limits float64 min_position float64 max_position # true if joint has velocity limits bool has_velocity_limits # max velocity limit float64 max_velocity # min_velocity is assumed to be -max_velocity # true if joint has acceleration limits bool has_acceleration_limits # max acceleration limit float64 max_acceleration # min_acceleration is assumed to be -max_acceleration # true if joint has jerk limits bool has_jerk_limits # max jerk limit float64 max_jerk # min_jerk is assumed to be -max_jerk
     srv: ListRobotStatesInWarehouse
       request:
         string regex string robot

       response:
         string[] states
     msg: Constraints
       message:
         # This message contains a list of motion planning constraints. # All constraints must be satisfied for a goal to be considered valid string name JointConstraint[] joint_constraints PositionConstraint[] position_constraints OrientationConstraint[] orientation_constraints VisibilityConstraint[] visibility_constraints
     msg: PlaceLocation
       message:
         # A name for this grasp string id # The internal posture of the hand for the grasp # positions and efforts are used "trajectory_msgs.JointTrajectory" post_place_posture # The position of the end-effector for the grasp relative to a reference frame # (that is always specified elsewhere, not in this message) "geometry_msgs.PoseStamped" place_pose # The estimated probability of success for this place, or some other # measure of how "good" it is. float64 quality # The approach motion GripperTranslation pre_place_approach # The retreat motion GripperTranslation post_place_retreat # an optional list of obstacles that we have semantic information about # and that can be "touched.pushed.moved" in the course of grasping string[] allowed_touch_objects
     msg: MotionSequenceItem
       message:
         # The plan request for this item. # It is the planning request for this segment of the sequence, as if it were a solitary motion. MotionPlanRequest req # To blend between sequence items, the motion may be smoothed using a circular motion. # The blend radius of the circle between this and the next command, where 0 means no blending. float64 blend_radius
     srv: GetStateValidity
       request:
         RobotState robot_state string group_name Constraints constraints

       response:
         bool valid ContactInformation[] contacts CostSource[] cost_sources ConstraintEvalResult[] constraint_result
     msg: CartesianTrajectory
       message:
         # This message describes the trajectory of a tracked frame in task-space "std_msgs.Header" header # The name of the Cartesian frame being tracked with respect to the base frame provided in header.frame_id string tracked_frame CartesianTrajectoryPoint[] points
     srv: ChangeDriftDimensions
       request:
         # For use with moveit_jog_arm Cartesian planner # # Allow the robot to drift along these dimensions in a smooth but unregulated way. # Give 'true' to enable drift in the direction, 'false' to disable. # For example, may allow wrist rotation by drift_x_rotation == true. bool drift_x_translation bool drift_y_translation bool drift_z_translation bool drift_x_rotation bool drift_y_rotation bool drift_z_rotation # Not implemented as of Jan 2020 (for now assumed to be the identity matrix). In the future it will allow us to transform # from the jog control frame to a unique drift frame, so the robot can drift along off-principal axes "geometry_msgs.Transform" transform_jog_frame_to_drift_frame

       response:
         bool success
     msg: ContactInformation
       message:
         # Standard ROS header contains information # about the frame in which this # contact is specified "std_msgs.Header" header # Position of the contact point "geometry_msgs.Point" position # Normal corresponding to the contact point "geometry_msgs.Vector3" normal # Depth of contact point float64 depth # Name of the first body that is in contact # This could be a link or a namespace that represents a body string contact_body_1 uint32 body_type_1 # Name of the second body that is in contact # This could be a link or a namespace that represents a body string contact_body_2 uint32 body_type_2 uint32 ROBOT_LINK=0 uint32 WORLD_OBJECT=1 uint32 ROBOT_ATTACHED=2
     srv: SaveRobotStateToWarehouse
       request:
         string name string robot "moveit_msgs.RobotState" state

       response:
         bool success
     srv: GetMotionPlan
       request:
         # This service contains the definition for a request to the motion # planner and the output it provides MotionPlanRequest motion_plan_request

       response:
         MotionPlanResponse motion_plan_response
     msg: DisplayRobotState
       message:
         # The robot state to display RobotState state # Optionally, various links can be highlighted ObjectColor[] highlight_links # If true, suppress the display in visualizations (like rviz) bool hide
     msg: JointConstraint
       message:
         # Constrain the position of a joint to be within a certain bound string joint_name # the bound to be achieved is [position - tolerance_below, position + tolerance_above] float64 position float64 tolerance_above float64 tolerance_below # A weighting factor for this constraint (denotes relative importance to other constraints. Closer to zero means less important) float64 weight
     msg: DisplayTrajectory
       message:
         # The model id for which this path has been generated string model_id # The representation of the path contains position values for all the joints that are moving along the path; a sequence of trajectories may be specified RobotTrajectory[] trajectory # The robot state is used to obtain positions for "all.some" of the joints of the robot. # It is used by the path display node to determine the positions of the joints that are not specified in the joint path message above. # If the robot state message contains joint position information for joints that are also mentioned in the joint path message, the positions in the joint path message will overwrite the positions specified in the robot state message. RobotState trajectory_start
     msg: GenericTrajectory
       message:
         # A generic trajectory message that may either encode a joint- or cartesian-space trajectory, or both # Trajectories encoded in this message are considered semantically equivalent "std_msgs.Header" header "trajectory_msgs.JointTrajectory"[] joint_trajectory "moveit_msgs.CartesianTrajectory"[] cartesian_trajectory
     srv: GetMotionSequence
       request:
         # Planning request with a list of motion commands MotionSequenceRequest request

       response:
         # Response to the planning request MotionSequenceResponse response
     srv: RenameRobotStateInWarehouse
       request:
         string old_name string new_name string robot

       response:
     msg: PositionIKRequest
       message:
         # A Position IK request message # The name of the group which will be used to compute IK # e.g. "right_arm", or "arms" - see IK specification for multiple-groups below # Information from the SRDF will be used to automatically determine which link # to solve IK for, unless ik_link_name is also specified string group_name # A RobotState consisting of "hint.seed" positions for the IK computation and positions # for all the other joints in the robot. Additional state information provided here is # used to specify starting positions for other "joints.links" on the robot. # This state MUST contain state for all joints to be used by the IK solver # to compute IK. The list of joints that the IK solver deals with can be # found using the SRDF for the corresponding group "moveit_msgs.RobotState" robot_state # A set of constraints that the IK must obey; by default, this set of constraints is empty Constraints constraints # Find an IK solution that avoids collisions. By default, this is false bool avoid_collisions # (OPTIONAL) The name of the link for which we are computing IK # If not specified, the link name will be inferred from a combination # of the group name and the SRDF. If any values are specified for ik_link_names, # this value is ignored string ik_link_name # The stamped pose of the link, when the IK solver computes the joint values # for all the joints in a group. This value is ignored if pose_stamped_vector # has any elements specified. "geometry_msgs.PoseStamped" pose_stamped # Multi-group parameters # (OPTIONAL) The names of the links for which we are computing IK # If not specified, the link name will be inferred from a combination # of the group name and the SRDF string[] ik_link_names # (OPTIONAL) The (stamped) poses of the links we are computing IK for (when a group has more than one end effector) # e.g. The "arms" group might consist of both the "right_arm" and the "left_arm" # The order of the groups referred to is the same as the order setup in the SRDF "geometry_msgs.PoseStamped"[] pose_stamped_vector # Maximum allowed time for IK calculation "builtin_interfaces.Duration" timeout
     msg: PositionConstraint
       message:
         # This message contains the definition of a position constraint. "std_msgs.Header" header # The robot link this constraint refers to string link_name # The offset (in the link frame) for the target point on the link we are planning for "geometry_msgs.Vector3" target_point_offset # The volume this constraint refers to BoundingVolume constraint_region # A weighting factor for this constraint (denotes relative importance to other constraints. Closer to zero means less important) float64 weight
     msg: MoveItErrorCodes
       message:
         int32 val # overall behavior int32 SUCCESS=1 int32 FAILURE=99999 int32 PLANNING_FAILED=-1 int32 INVALID_MOTION_PLAN=-2 int32 MOTION_PLAN_INVALIDATED_BY_ENVIRONMENT_CHANGE=-3 int32 CONTROL_FAILED=-4 int32 UNABLE_TO_AQUIRE_SENSOR_DATA=-5 int32 TIMED_OUT=-6 int32 PREEMPTED=-7 # planning & kinematics request errors int32 START_STATE_IN_COLLISION=-10 int32 START_STATE_VIOLATES_PATH_CONSTRAINTS=-11 int32 START_STATE_INVALID=-26 int32 GOAL_IN_COLLISION=-12 int32 GOAL_VIOLATES_PATH_CONSTRAINTS=-13 int32 GOAL_CONSTRAINTS_VIOLATED=-14 int32 GOAL_STATE_INVALID=-27 int32 UNRECOGNIZED_GOAL_TYPE=-28 int32 INVALID_GROUP_NAME=-15 int32 INVALID_GOAL_CONSTRAINTS=-16 int32 INVALID_ROBOT_STATE=-17 int32 INVALID_LINK_NAME=-18 int32 INVALID_OBJECT_NAME=-19 # system errors int32 FRAME_TRANSFORM_FAILURE=-21 int32 COLLISION_CHECKING_UNAVAILABLE=-22 int32 ROBOT_STATE_STALE=-23 int32 SENSOR_INFO_STALE=-24 int32 COMMUNICATION_FAILURE=-25 int32 CRASH=-29 int32 ABORT=-30 # kinematics errors int32 NO_IK_SOLUTION=-31
     msg: KinematicSolverInfo
       message:
         # A list of joints in the kinematic tree string[] joint_names # A list of joint limits corresponding to the joint names "moveit_msgs.JointLimits"[] limits # A list of links that the kinematics node provides solutions for string[] link_names
     srv: GetPositionFK
       request:
         # A service definition for a standard forward kinematics service # The frame_id in the header message is the frame in which # the forward kinematics poses will be returned "std_msgs.Header" header # A vector of link name for which forward kinematics must be computed string[] fk_link_names # A robot state consisting of joint names and joint positions to be used for forward kinematics RobotState robot_state

       response:
         # The resultant vector of PoseStamped messages that contains the (stamped) poses of the requested links "geometry_msgs.PoseStamped"[] pose_stamped # The list of link names corresponding to the poses string[] fk_link_names MoveItErrorCodes error_code
     srv: ChangeControlDimensions
       request:
         # For use with moveit_jog_arm Cartesian planner # # Turn "on.off" jogging along these dimensions. # Give 'true' to enable jogging in the direction, 'false' to disable bool control_x_translation bool control_y_translation bool control_z_translation bool control_x_rotation bool control_y_rotation bool control_z_rotation

       response:
         bool success
     msg: ConstraintEvalResult
       message:
         # This message contains result from constraint evaluation # result specifies the result of constraint evaluation # (true indicates state satisfies constraint, false indicates state violates constraint) # if false, distance specifies a measure of the distance of the state from the constraint # if true, distance is set to zero bool result float64 distance
     srv: ApplyPlanningScene
       request:
         PlanningScene scene

       response:
         bool success
     msg: TrajectoryConstraints
       message:
         # The array of constraints to consider along the trajectory Constraints[] constraints
     msg: MotionSequenceRequest
       message:
         # List of motion planning request with a blend_radius for each. # In the response of the planner all of these will be executable as one sequence. MotionSequenceItem[] items
     srv: CheckIfRobotStateExistsInWarehouse
       request:
         string name string robot

       response:
         bool exists
     srv: GetPlanningScene
       request:
         # Get parts of the planning scene that are of interest # All scene components are returned if none are specified PlanningSceneComponents components

       response:
         PlanningScene scene
     msg: PlannerInterfaceDescription
       message:
         # The name of the planner interface string name # The name of the planning pipeline string pipeline_id # The names of the planner ids within the interface string[] planner_ids
     msg: PlannerParams
       message:
         # parameter names (same size as values) string[] keys # parameter values (same size as keys) string[] values # parameter description (can be empty) string[] descriptions
     srv: GetCartesianPath
       request:
         # Define the frame for the specified waypoints "std_msgs.Header" header # The start at which to start the Cartesian path RobotState start_state # Mandatory name of group to compute the path for string group_name # Optional name of IK link for which waypoints are specified. # If not specified, the tip of the group (which is assumed to be a chain) # is assumed to be the link string link_name # A sequence of waypoints to be followed by the specified link, # while moving the specified group, such that the group moves only # in a straight line between waypoints "geometry_msgs.Pose"[] waypoints # The maximum distance (in Cartesian space) between consecutive points # in the returned path. This must always be specified and > 0 float64 max_step # If jump_threshold is set > 0, it acts as a scaling factor that is used to # filter out large relative joint-space jumps in the generated Cartesian path. # To this end, the average joint-space distance between consecutive waypoints # is computed. If any joint-space distance is larger than this average distance # by a factor of jump_threshold_factor, this step is considered a jump # and the returned path is truncated before the step. float64 jump_threshold # If prismatic_jump_threshold or revolute_jump_threshold are set > 0, then for # all active prismatic or revolute joints, the joint-space difference between # consecutive waypoints is compared to the respective absolute threshold. # If any threshold is exceeded, this step is considered a jump and the returned path # is truncated before the step. float64 prismatic_jump_threshold float64 revolute_jump_threshold # Set to true if collisions should be avoided when possible bool avoid_collisions # Specify additional constraints to be met by the Cartesian path Constraints path_constraints

       response:
         # The state at which the computed path starts RobotState start_state # The computed solution trajectory, for the desired group, in configuration space RobotTrajectory solution # If the computation was incomplete, this value indicates the fraction of the path # that was in fact computed (number of waypoints traveled through) float64 fraction # The error code of the computation MoveItErrorCodes error_code
     msg: RobotTrajectory
       message:
         "trajectory_msgs.JointTrajectory" joint_trajectory "trajectory_msgs.MultiDOFJointTrajectory" multi_dof_joint_trajectory
     msg: CartesianPoint
       message:
         # This message defines a point in a cartesian trajectory "geometry_msgs.Pose" pose "geometry_msgs.Twist" velocity "geometry_msgs.Accel" acceleration
     srv: DeleteRobotStateFromWarehouse
       request:
         string name string robot

       response:
     msg: WorkspaceParameters
       message:
         # This message contains a set of parameters useful in # setting up the volume (a box) in which the robot is allowed to move. # This is useful only when planning for mobile parts of # the robot as well. # Define the frame of reference for the box corners "std_msgs.Header" header # The minumum corner of the box, with respect to the robot starting pose "geometry_msgs.Vector3" min_corner # The maximum corner of the box, with respect to the robot starting pose "geometry_msgs.Vector3" max_corner
